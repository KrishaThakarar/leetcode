##singley linked list

###problem:  Delete Node in a Linked List

###code:
class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val=node.next.val
        node.next=node.next.next


###problem:  Middle of the Linked List
Input: head = [1,2,3,4,5]
Output: [3,4,5]
Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.

###code:
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        arr=[head]
        while arr[-1].next:
            arr.append(arr[-1].next)
        return arr[len(arr)//2]
        

###problem:     reverse linked list
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Input: head = []
Output: []

###code:
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev=None
        curr=head
        while curr:
            next_temp=curr.next
            curr.next=prev
            prev=curr
            curr=next_temp
        return prev
        

##Slow pointer → moves 1 step at a time

 ##Fast pointer → moves 2 steps at a time

##for slow and fast type problem can solve with store data in that way 

##problem: linked list cycle 1
in takeuforwar
Example 1:
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

##ans 
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        nodes=set()
        current=head
        while current is not None:
            if current in nodes:
                return True
            nodes.add(current)
            current=current.next
        return False

##problem: linked list cycle 2
##ans
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        seen_node=set()
        node=head
        while node is not None:
            if node in seen_node:
                return node
            else:
                seen_node.add(node)
                node=node.next
        return None













##problem :subset
Example 1:

###Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:

Input: nums = [0]
Output: [[],[0]]

###Idea (Easy Explanation)
Start with an empty subset
For each number, you have two choices:
Include it in the current subset
Exclude it
Recursively explore all possibilities
Store every subset you create\

